https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html


Kind																				Example
Reference to a static method														ContainingClass::staticMethodName
Reference to an instance method of a particular object								containingObject::instanceMethodName
Reference to an instance method of an arbitrary object of a particular type			ContainingType::methodName
Reference to a constructor															ClassName::new

https://coderanch.com/t/712821/java/explain-Reference-instance-method-arbitrary



private void trackFirmBillingChanges(long companyId, Firmbilling previous, Firmbilling current) {
    EventPublisher eventPublisher = RedihiveApplicationContextHolder.getBean(EventPublisher.class);
	//BiConsumer<...> is Functional interface
	//You provide and implementation by lambda
	BiConsumer<String, Function<Firmbilling, Object>> tracker = (type, getter) -> {
		//the second parameter is also an Functional Interface: Function<...>
		//You use the interface by apply(...), 
		//please note, the parameter for apply(...) is type Firmbilling, that is why when you provide implementation by:
		//Firmbilling::getPayorname, it compiles without an error.
	    Object oldValue = getter.apply(previous);
	    //Also, here, you access to the variable previous/current, it is Effective Final. 
	    Object newValue = getter.apply(current);
	
	    if (!Objects.equals(oldValue, newValue)) {
	
	        eventPublisher.send(
	                type,
	                ImmutableMap.<String, Object>builder()
	                        .put("companyId", companyId)
	                        .put("oldValue", Optional.ofNullable(oldValue).orElse(""))
	                        .put("newValue", Optional.ofNullable(newValue).orElse(""))
	                        .build()
	        );
	    }
	};

	//You call the implementation
	//You provide the second parameter by provide an:
	//		Reference to an instance method of an arbitrary object of a particular type	
	tracker.accept("COMPANY_BILLING_NAME_CHANGE", Firmbilling::getPayorname);
	
	
}





Key to understand lambda function or functional interface:
in previous java programming model, you provide function on the method, you call the method by provide data to it.
in lambda programming model, you provide data inside of the method, you call the method by provide the function.


VXEntityManager.usingMxValuesTx(entityManager -> {
                PartyWFHandler partyWFHandler = new PartyWFHandler();
                String url;

                // VAL-29116: if consul connect is enabled, set the url for security service to the local envoy proxy to access over the service mesh
                url = getSecurityServiceUrl(partyWFHandler, entityManager);

                CommonResourceClient commonResourceClient = new CommonResourceClient(url, EMAIL_POST_PATH);

                Map<String, Object> requestMap = new HashMap<>();
                requestMap.put(EMAIL_ADDRESS, emailAddress);
                requestMap.put(FIRST_NAME, firstName);
                requestMap.put(LAST_NANE, language);
                requestMap.put(PLATFORM, platform);
                requestMap.put(LANGUAGE, language);
                Map responseMap =
                        commonResourceClient.executeGeneralProcess(requestMap, Map.class, ResourceRequestType.POST);
                if (responseMap != null) {
                    String key = (String) responseMap.get(USER_KEY);
                    UserWFHandler userWFHandler = new UserWFHandler();
                    Credential credential = userWFHandler.getCredential(userId, entityManager);
                    credential.setOtpKey(key);
                    entityManager.persist(credential);
                }
            });
            
            
    public static void usingMxValuesTx(Consumer<EntityManager> emConsumer) {
        usingTx(vxEntityManager::getMXValuesEntityManager, emConsumer);
    }
    
    
    private static void usingTx(Supplier<EntityManager> emSupplier, Consumer<EntityManager> emConsumer) {
        usingTx(emSupplier, em -> {
            emConsumer.accept(em);
            return null;
        });
    }
    
    
    private static <T> T usingTx(Supplier<EntityManager> emSupplier, Function<EntityManager, T> emFunction) {
        return using(emSupplier, em -> {
            try {
                em.getTransaction().begin();
                T result = emFunction.apply(em);
                em.getTransaction().commit();
                return result;
            } catch (Throwable t) {
                LOG.error("", t);

                if (em != null && em.getTransaction().isActive()) {
                    em.getTransaction().rollback();
                }

                throw t;
            }
        });
    }    
    
    
    private static <T> T using(Supplier<EntityManager> emSupplier, Function<EntityManager, T> emFunction) {
        EntityManager em = null;

        try {
            em = emSupplier.get();
            return emFunction.apply(em);
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }    
    //the above code is interesting, looks the "EntityManager em" is the data you have, but, its real value coming from the lambda you provide.
    
    
    
    
    
    
    
    
    
    
                    
